// Code generated by counterfeiter. DO NOT EDIT.
package commandparserfakes

import (
	"sync"

	"github.com/cloudfoundry/stembuild/commandparser"
)

type FakePackagerMessenger struct {
	CannotCreatePackagerStub        func(error)
	cannotCreatePackagerMutex       sync.RWMutex
	cannotCreatePackagerArgsForCall []struct {
		arg1 error
	}
	DoesNotHaveEnoughSpaceStub        func(error)
	doesNotHaveEnoughSpaceMutex       sync.RWMutex
	doesNotHaveEnoughSpaceArgsForCall []struct {
		arg1 error
	}
	InvalidOutputConfigStub        func(error)
	invalidOutputConfigMutex       sync.RWMutex
	invalidOutputConfigArgsForCall []struct {
		arg1 error
	}
	PackageFailedStub        func(error)
	packageFailedMutex       sync.RWMutex
	packageFailedArgsForCall []struct {
		arg1 error
	}
	SourceParametersAreInvalidStub        func(error)
	sourceParametersAreInvalidMutex       sync.RWMutex
	sourceParametersAreInvalidArgsForCall []struct {
		arg1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePackagerMessenger) CannotCreatePackager(arg1 error) {
	fake.cannotCreatePackagerMutex.Lock()
	fake.cannotCreatePackagerArgsForCall = append(fake.cannotCreatePackagerArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("CannotCreatePackager", []interface{}{arg1})
	fake.cannotCreatePackagerMutex.Unlock()
	if fake.CannotCreatePackagerStub != nil {
		fake.CannotCreatePackagerStub(arg1)
	}
}

func (fake *FakePackagerMessenger) CannotCreatePackagerCallCount() int {
	fake.cannotCreatePackagerMutex.RLock()
	defer fake.cannotCreatePackagerMutex.RUnlock()
	return len(fake.cannotCreatePackagerArgsForCall)
}

func (fake *FakePackagerMessenger) CannotCreatePackagerCalls(stub func(error)) {
	fake.cannotCreatePackagerMutex.Lock()
	defer fake.cannotCreatePackagerMutex.Unlock()
	fake.CannotCreatePackagerStub = stub
}

func (fake *FakePackagerMessenger) CannotCreatePackagerArgsForCall(i int) error {
	fake.cannotCreatePackagerMutex.RLock()
	defer fake.cannotCreatePackagerMutex.RUnlock()
	argsForCall := fake.cannotCreatePackagerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePackagerMessenger) DoesNotHaveEnoughSpace(arg1 error) {
	fake.doesNotHaveEnoughSpaceMutex.Lock()
	fake.doesNotHaveEnoughSpaceArgsForCall = append(fake.doesNotHaveEnoughSpaceArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("DoesNotHaveEnoughSpace", []interface{}{arg1})
	fake.doesNotHaveEnoughSpaceMutex.Unlock()
	if fake.DoesNotHaveEnoughSpaceStub != nil {
		fake.DoesNotHaveEnoughSpaceStub(arg1)
	}
}

func (fake *FakePackagerMessenger) DoesNotHaveEnoughSpaceCallCount() int {
	fake.doesNotHaveEnoughSpaceMutex.RLock()
	defer fake.doesNotHaveEnoughSpaceMutex.RUnlock()
	return len(fake.doesNotHaveEnoughSpaceArgsForCall)
}

func (fake *FakePackagerMessenger) DoesNotHaveEnoughSpaceCalls(stub func(error)) {
	fake.doesNotHaveEnoughSpaceMutex.Lock()
	defer fake.doesNotHaveEnoughSpaceMutex.Unlock()
	fake.DoesNotHaveEnoughSpaceStub = stub
}

func (fake *FakePackagerMessenger) DoesNotHaveEnoughSpaceArgsForCall(i int) error {
	fake.doesNotHaveEnoughSpaceMutex.RLock()
	defer fake.doesNotHaveEnoughSpaceMutex.RUnlock()
	argsForCall := fake.doesNotHaveEnoughSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePackagerMessenger) InvalidOutputConfig(arg1 error) {
	fake.invalidOutputConfigMutex.Lock()
	fake.invalidOutputConfigArgsForCall = append(fake.invalidOutputConfigArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("InvalidOutputConfig", []interface{}{arg1})
	fake.invalidOutputConfigMutex.Unlock()
	if fake.InvalidOutputConfigStub != nil {
		fake.InvalidOutputConfigStub(arg1)
	}
}

func (fake *FakePackagerMessenger) InvalidOutputConfigCallCount() int {
	fake.invalidOutputConfigMutex.RLock()
	defer fake.invalidOutputConfigMutex.RUnlock()
	return len(fake.invalidOutputConfigArgsForCall)
}

func (fake *FakePackagerMessenger) InvalidOutputConfigCalls(stub func(error)) {
	fake.invalidOutputConfigMutex.Lock()
	defer fake.invalidOutputConfigMutex.Unlock()
	fake.InvalidOutputConfigStub = stub
}

func (fake *FakePackagerMessenger) InvalidOutputConfigArgsForCall(i int) error {
	fake.invalidOutputConfigMutex.RLock()
	defer fake.invalidOutputConfigMutex.RUnlock()
	argsForCall := fake.invalidOutputConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePackagerMessenger) PackageFailed(arg1 error) {
	fake.packageFailedMutex.Lock()
	fake.packageFailedArgsForCall = append(fake.packageFailedArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("PackageFailed", []interface{}{arg1})
	fake.packageFailedMutex.Unlock()
	if fake.PackageFailedStub != nil {
		fake.PackageFailedStub(arg1)
	}
}

func (fake *FakePackagerMessenger) PackageFailedCallCount() int {
	fake.packageFailedMutex.RLock()
	defer fake.packageFailedMutex.RUnlock()
	return len(fake.packageFailedArgsForCall)
}

func (fake *FakePackagerMessenger) PackageFailedCalls(stub func(error)) {
	fake.packageFailedMutex.Lock()
	defer fake.packageFailedMutex.Unlock()
	fake.PackageFailedStub = stub
}

func (fake *FakePackagerMessenger) PackageFailedArgsForCall(i int) error {
	fake.packageFailedMutex.RLock()
	defer fake.packageFailedMutex.RUnlock()
	argsForCall := fake.packageFailedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePackagerMessenger) SourceParametersAreInvalid(arg1 error) {
	fake.sourceParametersAreInvalidMutex.Lock()
	fake.sourceParametersAreInvalidArgsForCall = append(fake.sourceParametersAreInvalidArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("SourceParametersAreInvalid", []interface{}{arg1})
	fake.sourceParametersAreInvalidMutex.Unlock()
	if fake.SourceParametersAreInvalidStub != nil {
		fake.SourceParametersAreInvalidStub(arg1)
	}
}

func (fake *FakePackagerMessenger) SourceParametersAreInvalidCallCount() int {
	fake.sourceParametersAreInvalidMutex.RLock()
	defer fake.sourceParametersAreInvalidMutex.RUnlock()
	return len(fake.sourceParametersAreInvalidArgsForCall)
}

func (fake *FakePackagerMessenger) SourceParametersAreInvalidCalls(stub func(error)) {
	fake.sourceParametersAreInvalidMutex.Lock()
	defer fake.sourceParametersAreInvalidMutex.Unlock()
	fake.SourceParametersAreInvalidStub = stub
}

func (fake *FakePackagerMessenger) SourceParametersAreInvalidArgsForCall(i int) error {
	fake.sourceParametersAreInvalidMutex.RLock()
	defer fake.sourceParametersAreInvalidMutex.RUnlock()
	argsForCall := fake.sourceParametersAreInvalidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePackagerMessenger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cannotCreatePackagerMutex.RLock()
	defer fake.cannotCreatePackagerMutex.RUnlock()
	fake.doesNotHaveEnoughSpaceMutex.RLock()
	defer fake.doesNotHaveEnoughSpaceMutex.RUnlock()
	fake.invalidOutputConfigMutex.RLock()
	defer fake.invalidOutputConfigMutex.RUnlock()
	fake.packageFailedMutex.RLock()
	defer fake.packageFailedMutex.RUnlock()
	fake.sourceParametersAreInvalidMutex.RLock()
	defer fake.sourceParametersAreInvalidMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePackagerMessenger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commandparser.PackagerMessenger = new(FakePackagerMessenger)
